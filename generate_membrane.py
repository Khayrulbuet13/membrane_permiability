import numpy as np
import argparse

def atom_coordinates_np(length, width, atom_distance, atom_radius):
    # Calculate the number of atoms that can be placed horizontally and vertically
    horizontal_atoms = int(length // (atom_distance + 2 * atom_radius))
    vertical_atoms = int(width // (atom_distance + 2 * atom_radius))

    # Use np.indices to create a grid of points
    grid = np.indices((horizontal_atoms, vertical_atoms))

    # Multiply the grid by the atom_distance to space the points out correctly
    grid = grid * (atom_distance + 2 * atom_radius)

    # Transpose and reshape the grid to get an array of points
    atoms = grid.T.reshape(-1, 2)

    # add hight axis to the atoms
    atoms = np.hstack((atoms, np.zeros((len(atoms), 1))))
    
    # add atom type
    atoms = np.hstack((np.ones((len(atoms), 1)), atoms))

    return atoms


def write_gro_file(atoms,  name_str_arr, filename, velocity = None):
    
    # extract values from atoms
    atom_type = atoms[:,0].astype(int)
    atom_coordinates = atoms[:,1:]
    
    with open(filename, 'w') as f:
        # Writing header
        f.write('Generated by script\n')
        
        # Writing number of atoms
        n_atoms = len(atom_coordinates)
        f.write(f'{n_atoms}\n')
        
        # define atom properties
        residue_index = 1
        residue_name = 'MOL'
        
        if velocity is None:
            velocity = np.zeros((n_atoms, 3))
        
        # Writing atom coordinates
        for i, (x, y, z) in enumerate(atom_coordinates, start=1):
            
            
            # Atom name
            atom_name = name_str_arr[atom_type[i-1]-1]
            # Atom velocity
            vx = velocity[i-1, 0]
            vy = velocity[i-1, 1]
            vz = velocity[i-1, 2]
            
            # Residue index, Residue name, Atom name, Atom number, Position (in nm)
            f.write(f'{residue_index:5d}{residue_name:5s}'  \
                    f'{atom_name:5s}{i:5d}'  \
                    f'{x:8.3f}{y:8.3f}{z:8.3f}'  \
                    f'{vx:8.4f}{vy:8.4f}{vz:8.4f}\n')
        
        # Writing box vectors (we don't have a box here, so vectors are 0)
        f.write(f'   0.00000   0.00000   0.00000\n')



def add_layers(coordinates, atom_distance, n_layers):
    """
    Add n layers of atoms at the specified distance from the given coordinates.

    Parameters:
    coordinates (numpy.ndarray): Array of initial atom coordinates
    atom_distance (float): Distance between atoms
    n_layers (int): Number of layers to add

    Returns:
    numpy.ndarray: Array of atom coordinates with additional layers
    """

    # Ensure coordinates is a numpy array
    atom_id = np.asarray(coordinates[:,0])
    coordinates = np.asarray(coordinates[:,1:])
    
    # Create array to hold new layers
    new_coordinates = coordinates.copy()
    new_id = atom_id.copy()
    max_type = np.max(atom_id)
    # Add layers
    for i in range(1, n_layers ):
        layer = coordinates.copy()
        layer[:, 2] += i * atom_distance  # Assume third column is z-coordinate
        new_coordinates = np.vstack([new_coordinates, layer])
        new_id = np.hstack([new_id, atom_id + max_type * i])

    new_atoms = np.hstack((new_id.reshape(-1,1), new_coordinates))

    return new_atoms

import numpy as np

def calculate_rdf(coordinates, atom_types, dr, r_max):
    """
    Calculate the radial distribution function.

    Parameters:
    coordinates (numpy.ndarray): The coordinates of the particles.
    atom_types (numpy.ndarray): The type of each atom.
    dr (float): The width of the bins in the histogram.
    r_max (float): The maximum distance to consider in the RDF calculation.

    Returns:
    tuple: (g, r) where g is the RDF and r is the array of distance bins.
    """
    from scipy.spatial.distance import pdist, squareform

    # Number of particles
    N = len(coordinates)

    # Calculate the pairwise distances
    r = pdist(coordinates)

    # Only consider distances up to r_max
    r = r[r < r_max]

    # Generate the bins for the histogram
    bins = np.arange(0, r_max, dr)

    # Calculate the histogram
    hist, edges = np.histogram(r, bins=bins)

    # Normalize the RDF
    rho = N / (4/3 * np.pi * r_max**3)  # density
    r = edges[:-1] + dr/2  # positions of the bin centers
    ideal_hist = 4 * np.pi * rho * r**2 * dr  # ideal histogram for a uniform distribution
    g = hist / ideal_hist

    return g, r


def generate_membrane(length, width, atom_distance, atom_radius, n_layers, filename, atom_names):
    """
    Generate a .gro file of atom coordinates.

    Parameters:
    length (float): The length of the 2D space.
    width (float): The width of the 2D space.
    atom_distance (float): The distance between atoms.
    atom_radius (float): The radius of the atoms.
    n_layers (int): The number of layers to add.
    filename (str): The name of the output .gro file.
    atom_names (str): A comma-separated list of atom names.
    """

    # Generate the atom coordinates
    atom_cord  = atom_coordinates_np(length, width, atom_distance, atom_radius)

    # Add layers to the coordinates
    added_layers = add_layers(atom_cord, atom_distance, n_layers)

    # # Split the atom names
    # atom_names = atom_names.split(',')

    # Generate the .gro file
    write_gro_file(added_layers, atom_names, filename)

    g, r = calculate_rdf(added_layers[:,1:], added_layers[:,0], .1, 5)
    import matplotlib.pyplot as plt
    # Plot the RDF
    plt.figure(figsize=(7, 5))
    plt.plot(r, g, label='g(r)')
    plt.title('Radial Distribution Function')
    plt.xlabel('Distance (r)')
    plt.ylabel('g(r)')
    plt.legend()
    plt.grid(True)
    plt.savefig(filename[:-4] + '.png')

if __name__ == "__main__":
    
    # Define the argument parser
    parser = argparse.ArgumentParser(description='Create a .gro file of atom coordinates.')

    # Add the arguments
    parser.add_argument('--length', type=float, default = 400, help='The length of the 2D space.')
    parser.add_argument('--width', type=float, default = 400, help='The width of the 2D space.')
    parser.add_argument('--atom_distance', type=float, default = 1, help='The distance between atoms.')
    parser.add_argument('--atom_radius', type=float, default = .5, help='The radius of the atoms.')
    parser.add_argument('--n_layers', type=int, default = 6, help='The number of layers to add.')
    parser.add_argument('--filename', type=str, required=True, help='The name of the output .gro file.')
    parser.add_argument('--atom_names', type=str, default = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'] , help='A comma-separated list of atom names.')

    # Parse the arguments
    args = parser.parse_args()
    
    generate_membrane(args.length, args.width, args.atom_distance, args.atom_radius, args.n_layers, args.filename, args.atom_names)
