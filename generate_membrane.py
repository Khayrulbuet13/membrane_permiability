import numpy as np
import argparse

"""
python script to generate a membrane
writeen by: Khayrul Islam, 2023
email: khayrulbuet13@gmail.com
"""

def atom_coordinates_np(length, width, atom_distance, atom_radius):
    # Calculate the number of atoms that can be placed horizontally and vertically
    horizontal_atoms = int(length // (atom_distance + 2 * atom_radius))
    vertical_atoms = int(width // (atom_distance + 2 * atom_radius))

    # Use np.indices to create a grid of points
    grid = np.indices((horizontal_atoms, vertical_atoms))

    # Multiply the grid by the atom_distance to space the points out correctly
    grid = grid * (atom_distance + 2 * atom_radius)

    # Transpose and reshape the grid to get an array of points
    atoms = grid.T.reshape(-1, 2)

    # add hight axis to the atoms
    atoms = np.hstack((atoms, np.zeros((len(atoms), 1))))
    
    # add atom type
    atoms = np.hstack((np.ones((len(atoms), 1)), atoms))

    return atoms


def write_gro_file(atoms,  name_str_arr, filename, parameters, box = None, velocity = None):
    
    # extract values from atoms
    atom_type = atoms[:,0].astype(int)
    atom_coordinates = atoms[:,1:]
    
    with open(filename, 'w') as f:
        # Writing header
        f.write('Generated by Khayrul with parameters: ' + parameters + '\n')
        
        # Writing number of atoms
        n_atoms = len(atom_coordinates)
        f.write(f'{n_atoms}\n')
        
        # define atom properties
        residue_index = 1
        residue_name = 'MOL'
        
        if velocity is None:
            velocity = np.zeros((n_atoms, 3))
        
        # Writing atom coordinates
        for i, (x, y, z) in enumerate(atom_coordinates):
            
            
            # Atom name
            atom_name = name_str_arr[atom_type[i]-1]
            # Atom velocity
            vx = velocity[i, 0]
            vy = velocity[i, 1]
            vz = velocity[i, 2]
            
            # Residue index, Residue name, Atom name, Atom number, Position (in nm)
            f.write(f'{residue_index:5d}{residue_name:5s}'  \
                    f'{atom_name:5s}{i+1:5d}'  \
                    f'{x:8.3f}{y:8.3f}{z:8.3f}'  \
                    f'{vx:8.4f}{vy:8.4f}{vz:8.4f}\n')
        
        # Writing box vectors (we don't have a box here, so vectors are 0)
        if box is None:
            f.write(f'   0.00000   0.00000   0.00000\n')
        else:
            f.write(f'{box[0]:10.5f}{box[1]:10.5f}{box[2]:10.5f}\n')



def add_layers(coordinates, layer_distance, atom_radius, n_layers, membrane_gap = None):
    """
    Add n layers of atoms at the specified distance from the given coordinates.

    Parameters:
    coordinates (numpy.ndarray): Array of initial atom coordinates
    atom_distance (float): Distance between atoms
    n_layers (int): Number of layers to add

    Returns:
    numpy.ndarray: Array of atom coordinates with additional layers
    """

    # Ensure coordinates is a numpy array
    atom_id = np.asarray(coordinates[:,0])
    coordinates = np.asarray(coordinates[:,1:])
    
    # Create array to hold new layers
    new_coordinates = coordinates.copy()
    new_id = atom_id.copy()
    max_type = np.max(atom_id)
    
    
    # Add layers
    layer = coordinates.copy()
    for i in range(1, n_layers ):
        if membrane_gap is not None and i == 3:
            layer[:, 2] += membrane_gap + (layer_distance + 2 * atom_radius) 
        else:
            layer[:, 2] += (layer_distance + 2 * atom_radius)  # Assume third column is z-coordinate
        new_coordinates = np.vstack([new_coordinates, layer])
        new_id = np.hstack([new_id, atom_id + max_type * i])

    new_atoms = np.hstack((new_id.reshape(-1,1), new_coordinates))

    return new_atoms


def generate_membrane(length, width, atom_distance, layer_distance, atom_radius, n_layers, membrane_gap, filename, atom_names):
    """
    Generate a .gro file of atom coordinates.

    Parameters:
    length (float): The length of the 2D space.
    width (float): The width of the 2D space.
    atom_distance (float): The distance between atoms.
    layer_distance (float): The distance between layers of atoms (in z-direction)
    atom_radius (float): The radius of the atoms.
    n_layers (int): The number of layers to add.
    filename (str): The name of the output .gro file.
    atom_names (str): A comma-separated list of atom names.
    """
    parameters = f'l: {length}, w: {width}, ad: {atom_distance}, ld: {layer_distance}, ar: {atom_radius}, nl: {n_layers}, mg: {membrane_gap}'

    
    # Generate the atom coordinates
    atom_cord  = atom_coordinates_np(length, width, atom_distance, atom_radius)
    
    # Add layers to the coordinates
    added_layers = add_layers(atom_cord, layer_distance, atom_radius, n_layers, membrane_gap)

    # Generate the .gro file
    write_gro_file(added_layers, atom_names, filename, parameters, velocity = None)
    
    
    
if __name__ == "__main__":
    
    # Define the argument parser
    parser = argparse.ArgumentParser(description='Create a .gro file of atom coordinates.')

    # Add the arguments
    parser.add_argument('--length', type=float, default = 50, help='The length of the 2D space.')
    parser.add_argument('--width', type=float, default = 50, help='The width of the 2D space.')
    parser.add_argument('--atom_distance', type=float, default = 0, help='The distance between atoms.')
    parser.add_argument('--layer_distance', type=float, default = 0, help='The distance between layers of atoms.')
    parser.add_argument('--atom_radius', type=float, default = .5, help='The radius of the atoms.')
    parser.add_argument('--n_layers', type=int, default = 6, help='The number of layers to add.')
    parser.add_argument('--membrane_gap', type=float, default = 0, help='gap between membrane layer.')
    parser.add_argument('--filename', type=str, required=True, help='The name of the output .gro file.')
    parser.add_argument('--atom_names', type=str, default = ['H1', 'T1', 'T2', 'T3', 'T4', 'H2'] , help='A comma-separated list of atom names.')

    # Parse the arguments
    args = parser.parse_args()
    
    generate_membrane(args.length, args.width, args.atom_distance, args.layer_distance, args.atom_radius, args.n_layers, 
                      args.membrane_gap, args.filename, args.atom_names)
